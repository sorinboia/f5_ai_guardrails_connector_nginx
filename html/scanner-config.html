<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Guardrails Scan Configuration</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script>
      window.tailwind = window.tailwind || {};
      window.tailwind.config = {
        theme: {
          extend: {
            colors: {
              primary: {
                DEFAULT: '#2563eb',
                dark: '#1d4ed8'
              }
            }
          }
        }
      };
    </script>
    <script src="https://cdn.tailwindcss.com?plugins=forms"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body class="bg-slate-100 text-slate-900">
    <div class="min-h-screen bg-gradient-to-br from-slate-100 via-slate-50 to-slate-200 py-10">
      <div class="mx-auto max-w-6xl px-4 sm:px-6 lg:px-8">
        <header class="mb-10 text-center">
          <p class="text-sm uppercase tracking-wide text-slate-500">Calypso Guardrails</p>
          <h1 class="mt-2 text-4xl font-semibold text-slate-900">Scanning Control Panel</h1>
          <p class="mt-4 text-base text-slate-600">
            Refine how the proxy inspects traffic, redacts sensitive content, and records telemetry. Updates persist immediately to the NGINX key-value store.
          </p>
        </header>
        <div id="root"></div>
      </div>
    </div>

    <script type="text/babel" data-presets="react">
      const { useState, useEffect, useMemo, useRef } = React;

      const DEFAULT_HOST = '__default__';
      const STORAGE_KEYS = {
        selectedHost: 'guardrails:last-selected-host'
      };

      function normalizeHost(value) {
        if (!value) return DEFAULT_HOST;
        const trimmed = String(value).trim().toLowerCase();
        return trimmed || DEFAULT_HOST;
      }

      function hostDisplayLabel(host) {
        return host === DEFAULT_HOST ? 'Default (__default__)' : host;
      }

      function readPersistedHost() {
        if (typeof window === 'undefined' || !window.localStorage) return null;
        try {
          const raw = window.localStorage.getItem(STORAGE_KEYS.selectedHost);
          return raw ? normalizeHost(raw) : null;
        } catch (_) {
          return null;
        }
      }

      function persistSelectedHost(host) {
        if (typeof window === 'undefined' || !window.localStorage) return;
        try {
          window.localStorage.setItem(STORAGE_KEYS.selectedHost, normalizeHost(host));
        } catch (_) {
          // Ignore storage failures (e.g., private browsing).
        }
      }

      function hydrateExtractorList(value, fallback = []) {
        if (Array.isArray(value)) {
          return value.map(item => String(item)).map(item => item.trim()).filter(Boolean);
        }
        if (typeof value === 'string' && value.trim()) {
          if (value.trim().startsWith('[')) {
            try {
              const parsed = JSON.parse(value.trim());
              return hydrateExtractorList(parsed, fallback);
            } catch (_) {
              return [value.trim()];
            }
          }
          if (value.indexOf(',') !== -1) {
            return value.split(',').map(part => part.trim()).filter(Boolean);
          }
          return [value.trim()];
        }
        return Array.isArray(fallback) ? fallback.slice() : [];
      }

      function hydrateConfig(raw) {
        if (!raw || typeof raw !== 'object') return raw;
        const requestExtractors = hydrateExtractorList(raw.requestExtractors, raw.requestExtractor ? [raw.requestExtractor] : []);
        const responseExtractors = hydrateExtractorList(raw.responseExtractors, raw.responseExtractor ? [raw.responseExtractor] : []);
        return {
          ...raw,
          requestExtractors,
          responseExtractors,
          extractorParallelEnabled: !!raw.extractorParallelEnabled
        };
      }

      function inspectDirectionEnabled(mode, direction) {
        const normalized = String(mode || '').toLowerCase();
        if (direction === 'request') {
          return normalized === 'both' || normalized === 'request';
        }
        if (direction === 'response') {
          return normalized === 'both' || normalized === 'response';
        }
        return false;
      }

      function parseRedactMode(mode) {
        const normalized = String(mode || '').toLowerCase();
        if (normalized === 'both') return new Set(['request', 'response']);
        if (normalized === 'request') return new Set(['request']);
        if (normalized === 'response') return new Set(['response']);
        return new Set();
      }

      function formatRedactMode(contexts) {
        const hasRequest = contexts.has('request');
        const hasResponse = contexts.has('response');
        if (hasRequest && hasResponse) return 'both';
        if (hasRequest) return 'request';
        if (hasResponse) return 'response';
        return 'off';
      }

      function computeEffectiveRedactMode(config) {
        if (!config) return 'off';
        const contexts = parseRedactMode(config.redactMode);
        const inspectMode = config.inspectMode;
        if (!inspectDirectionEnabled(inspectMode, 'request')) contexts.delete('request');
        if (!inspectDirectionEnabled(inspectMode, 'response')) contexts.delete('response');

        if (config.requestForwardMode === 'parallel' && inspectDirectionEnabled(inspectMode, 'request')) {
          contexts.delete('request');
        }

        if (config.extractorParallelEnabled) {
          const requestParallel = Array.isArray(config.requestExtractors) && config.requestExtractors.length > 0;
          const responseParallel = Array.isArray(config.responseExtractors) && config.responseExtractors.length > 0;
          if (requestParallel && inspectDirectionEnabled(inspectMode, 'request')) {
            contexts.delete('request');
          }
          if (responseParallel && inspectDirectionEnabled(inspectMode, 'response')) {
            contexts.delete('response');
          }
        }

        return formatRedactMode(contexts);
      }

      function describeRedactionConstraints(config) {
        if (!config) return '';
        const parts = [];
        const inspectMode = config.inspectMode;
        if (config.requestForwardMode === 'parallel' && inspectDirectionEnabled(inspectMode, 'request')) {
          parts.push('Request redaction pauses while forwarding runs in parallel.');
        }
        if (config.extractorParallelEnabled) {
          const requestParallel = Array.isArray(config.requestExtractors) && config.requestExtractors.length > 0 && inspectDirectionEnabled(inspectMode, 'request');
          const responseParallel = Array.isArray(config.responseExtractors) && config.responseExtractors.length > 0 && inspectDirectionEnabled(inspectMode, 'response');
          if (requestParallel && responseParallel) {
            parts.push('Parallel extractors disable redaction for both directions.');
          } else if (requestParallel) {
            parts.push('Parallel request extractors disable request redaction.');
          } else if (responseParallel) {
            parts.push('Parallel response extractors disable response redaction.');
          }
        }
        return parts.join(' ');
      }

      const NAV_SECTIONS = [
        { id: 'overview', label: 'Overview' },
        { id: 'inspection', label: 'Inspection Modes' },
        { id: 'extraction', label: 'Extraction Paths' },
        { id: 'telemetry', label: 'Redaction & Logging' }
      ];

      const pathname = window.location.pathname || '';
      const PAGE_KIND = pathname.endsWith('/keys')
        ? 'keys'
        : pathname.endsWith('/patterns')
          ? 'patterns'
          : 'config';

      const PAGE_LINKS = [
        { id: 'config', label: 'Scan Config', href: '/config/ui' },
        { id: 'keys', label: 'API Keys', href: '/config/ui/keys' },
        { id: 'patterns', label: 'Pattern Rules', href: '/config/ui/patterns' }
      ];

      const ICONS = {
        loading: '⏳',
        success: '✅',
        error: '⚠️',
        info: 'ℹ️'
      };

      const toneClasses = {
        loading: 'border-slate-300 bg-slate-100 text-slate-600',
        success: 'border-emerald-200 bg-emerald-50 text-emerald-700',
        error: 'border-rose-200 bg-rose-50 text-rose-700',
        info: 'border-sky-200 bg-sky-50 text-sky-700'
      };

      const ToastStack = ({ toasts, dismiss }) => (
        <div className="fixed top-6 right-6 z-50 space-y-3">
          {toasts.map(toast => (
            <div
              key={toast.id}
              className={`flex items-start gap-3 rounded-xl border px-4 py-3 shadow-lg backdrop-blur ${toneClasses[toast.tone] || toneClasses.info}`}
            >
              <span className="text-xl leading-none">{ICONS[toast.tone] || ICONS.info}</span>
              <div className="flex-1 text-sm">{toast.message}</div>
              <button
                type="button"
                className="rounded-md p-1 text-xs text-slate-500 hover:text-slate-700"
                onClick={() => dismiss(toast.id)}
                aria-label="Dismiss notification"
              >
                ✕
              </button>
            </div>
          ))}
        </div>
      );

      const StatusBanner = ({ status }) => {
        if (!status.message) return null;
        const tone = toneClasses[status.tone] || toneClasses.info;
        return (
          <div className={`flex items-center gap-3 rounded-xl border px-4 py-3 text-sm shadow-sm ${tone}`}>
            <span className="text-lg leading-none">{ICONS[status.tone] || ICONS.info}</span>
            <span>{status.message}</span>
          </div>
        );
      };

      const Modal = ({ open, title, description, onClose, children, actions }) => {
        useEffect(() => {
          if (!open) return undefined;
          const handleKey = event => {
            if (event.key === 'Escape') {
              event.stopPropagation();
              if (onClose) onClose();
            }
          };
          window.addEventListener('keydown', handleKey);
          return () => {
            window.removeEventListener('keydown', handleKey);
          };
        }, [open, onClose]);

        if (!open) return null;

        const handleOverlayClick = event => {
          if (event.target === event.currentTarget && onClose) {
            onClose();
          }
        };

        return (
          <div
            className="fixed inset-0 z-50 flex items-center justify-center bg-slate-900/50 px-4"
            onClick={handleOverlayClick}
            role="dialog"
            aria-modal="true"
          >
            <div className="w-full max-w-lg space-y-6 rounded-2xl border border-slate-200 bg-white p-6 shadow-xl">
              <div className="flex items-start justify-between gap-4">
                <div>
                  <h2 className="text-lg font-semibold text-slate-800">{title}</h2>
                  {description ? <p className="mt-1 text-sm text-slate-500">{description}</p> : null}
                </div>
                <button
                  type="button"
                  className="rounded-md p-1 text-slate-500 hover:text-slate-700"
                  onClick={onClose}
                  aria-label="Close dialog"
                >
                  ✕
                </button>
              </div>
              <div>{children}</div>
              {actions ? <div className="flex justify-end gap-3">{actions}</div> : null}
            </div>
          </div>
        );
      };

      const SelectField = ({ label, helper, options, value, onChange, disabled }) => (
        <div className="space-y-2">
          <label className="block text-sm font-medium text-slate-700">{label}</label>
          <select
            className="block w-full rounded-lg border-slate-300 bg-white focus:border-primary focus:ring-primary"
            value={value}
            onChange={event => onChange(event.target.value)}
            disabled={disabled}
          >
            {options.map(option => (
              <option key={option} value={option}>
                {option}
              </option>
            ))}
          </select>
          {helper && <p className="text-sm text-slate-500">{helper}</p>}
        </div>
      );

      const SectionCard = React.forwardRef(({ id, title, description, children }, ref) => (
        <section
          ref={ref}
          id={id}
          className="scroll-mt-32 rounded-3xl border border-slate-200 bg-white p-6 shadow-sm"
        >
          <div className="mb-6 flex items-start justify-between gap-4">
            <div>
              <h2 className="text-2xl font-semibold text-slate-900">{title}</h2>
              {description && <p className="mt-2 text-sm text-slate-500">{description}</p>}
            </div>
          </div>
          <div className="space-y-6">{children}</div>
        </section>
      ));

      const StickyNav = ({ activeSection, onNavigate, isDirty }) => (
        <aside className="lg:sticky lg:top-24">
          <div className="rounded-3xl border border-slate-200 bg-white p-5 shadow-sm">
            <p className="text-sm font-semibold text-slate-600">Configuration Sections</p>
            <nav className="mt-4 space-y-1">
              {NAV_SECTIONS.map(item => {
                const isActive = activeSection === item.id;
                return (
                  <button
                    key={item.id}
                    type="button"
                    onClick={() => onNavigate(item.id)}
                    aria-current={isActive ? 'true' : 'false'}
                    className={`group flex w-full items-center gap-3 rounded-lg px-2 py-2 text-left text-sm font-medium transition ${
                      isActive ? 'text-primary' : 'text-slate-600 hover:text-slate-900'
                    }`}
                  >
                    <span
                      className={`h-2 w-2 rounded-full border transition ${
                        isActive
                          ? 'border-primary bg-primary'
                          : 'border-slate-300 bg-transparent group-hover:border-slate-400'
                      }`}
                    ></span>
                    <span className="flex-1">{item.label}</span>
                  </button>
                );
              })}
            </nav>
            {isDirty && (
              <p className="mt-4 rounded-lg border border-amber-200 bg-amber-50 px-3 py-2 text-xs text-amber-700">
                Unsaved changes detected. Remember to save before leaving.
              </p>
            )}
          </div>
        </aside>
      );

      const SummaryChips = ({ config }) => {
        if (!config) return null;
        const configuredRedact = config.redactMode && String(config.redactMode).trim() ? config.redactMode : 'off';
        const effectiveRedact = computeEffectiveRedactMode(config);
        const redactChip = configuredRedact === effectiveRedact
          ? effectiveRedact
          : `${configuredRedact} → ${effectiveRedact}`;
        const chips = [
          { label: 'Inspect', value: config.inspectMode },
          { label: 'Forwarding', value: config.requestForwardMode || '—' },
          { label: 'Redact', value: redactChip },
          { label: 'Log Level', value: config.logLevel },
          { label: 'Request Profiles', value: (config.requestExtractors || []).length },
          { label: 'Response Profiles', value: (config.responseExtractors || []).length }
        ];
        return (
          <div className="flex flex-wrap gap-3">
            {chips.map((chip, index) => (
              <span
                key={index}
                className="inline-flex items-center gap-2 rounded-full bg-slate-100 px-4 py-1.5 text-xs font-semibold text-slate-600"
              >
                <span className="uppercase tracking-wide text-[0.65rem] text-slate-400">{chip.label}</span>
                <span>{chip.value}</span>
              </span>
            ))}
          </div>
        );
      };

      const TopNavigation = ({ current }) => (
        <div className="mb-8 flex justify-center">
          <div className="inline-flex rounded-full border border-slate-300 bg-white/80 p-1 shadow-sm">
            {PAGE_LINKS.map(link => {
              const isActive = current === link.id;
              return (
                <a
                  key={link.id}
                  href={link.href}
                  className={classNames(
                    'mx-1 rounded-full px-4 py-2 text-sm font-semibold transition',
                    isActive ? 'bg-blue-600 text-white shadow hover:bg-blue-700' : 'text-slate-600 hover:bg-slate-100'
                  )}
                >
                  {link.label}
                </a>
              );
            })}
          </div>
        </div>
      );

      const PatternMultiSelector = ({ label, helper, patterns, values, onToggle, disabled, note }) => (
        <div className="space-y-3">
          <div className="flex items-start justify-between gap-3">
            <div>
              <p className="text-sm font-semibold text-slate-700">{label}</p>
              {helper && <p className="text-sm text-slate-500">{helper}</p>}
              {note && <p className="text-xs text-slate-500">{note}</p>}
            </div>
            {patterns.length ? (
              <span className="rounded-full bg-slate-200 px-3 py-1 text-xs font-semibold text-slate-700">{values.length} selected</span>
            ) : null}
          </div>
          {patterns.length === 0 ? (
            <p className="text-sm text-slate-500">No patterns available. Configure them on the Pattern Rules page.</p>
          ) : (
            <div className="space-y-2">
              {patterns.map(pattern => {
                const checked = values.indexOf(pattern.id) !== -1;
                return (
                  <label
                    key={pattern.id}
                    className={`flex items-center justify-between gap-3 rounded-xl border px-3 py-2 text-sm ${checked ? 'border-primary/60 bg-primary/5' : 'border-slate-200 bg-white'}`}
                  >
                    <div className="flex flex-col">
                      <span className="font-semibold text-slate-700">{pattern.name}</span>
                      <span className="text-xs text-slate-500">API key {pattern.apiKeyName}</span>
                    </div>
                    <input
                      type="checkbox"
                      className="h-4 w-4 rounded border-slate-300 text-primary focus:ring-primary"
                      disabled={disabled}
                      checked={checked}
                      onChange={event => onToggle(pattern.id, event.target.checked)}
                    />
                  </label>
                );
              })}
            </div>
          )}
        </div>
      );

      const HostSelector = ({ hosts, selectedHost, onSelect, onCreate, onDelete }) => {
        return (
          <div className="space-y-3 rounded-2xl border border-slate-200 bg-white p-4 shadow-sm">
            <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
              <div>
                <p className="text-sm font-semibold text-slate-700">Active Host</p>
                <p className="text-xs text-slate-500">Choose which Host header this configuration applies to.</p>
              </div>
              <div className="flex flex-col gap-2 sm:flex-row sm:items-center">
                <select
                  className="min-w-[12rem] rounded-lg border border-slate-300 bg-white px-3 py-2 text-sm focus:border-primary focus:ring-primary"
                  value={selectedHost}
                  onChange={event => onSelect(event.target.value)}
                >
                  {hosts.map(host => (
                    <option key={host} value={host}>
                      {hostDisplayLabel(host)}
                    </option>
                  ))}
                </select>
                <div className="flex gap-2">
                  <button
                    type="button"
                    onClick={onCreate}
                    className="inline-flex justify-center rounded-lg border border-primary px-3 py-1.5 text-sm font-medium text-primary shadow-sm hover:bg-primary/10"
                  >
                    New Host
                  </button>
                  <button
                    type="button"
                    onClick={() => onDelete(selectedHost)}
                    className="inline-flex justify-center rounded-lg border border-rose-200 px-3 py-1.5 text-sm font-medium text-rose-600 shadow-sm hover:bg-rose-50 disabled:opacity-50"
                    disabled={selectedHost === DEFAULT_HOST || hosts.length <= 1}
                  >
                    Delete
                  </button>
                </div>
              </div>
            </div>
          </div>
        );
      };

      const ConfigApp = () => {
        const sectionRefs = useRef({});
        const hasSyncedHostRef = useRef(false);
        const [status, setStatus] = useState({ tone: 'loading', message: 'Loading configuration…' });
        const [config, setConfig] = useState(null);
        const [serverConfig, setServerConfig] = useState(null);
        const [defaults, setDefaults] = useState(null);
        const [options, setOptions] = useState({ inspectMode: [], redactMode: [], logLevel: [], requestForwardMode: [] });
        const [updatedAt, setUpdatedAt] = useState(null);
        const [saving, setSaving] = useState(false);
        const [activeSection, setActiveSection] = useState(NAV_SECTIONS[0].id);
        const [toasts, setToasts] = useState([]);
        const [hosts, setHosts] = useState([DEFAULT_HOST]);
        const [selectedHost, setSelectedHost] = useState(DEFAULT_HOST);
        const [patterns, setPatterns] = useState([]);

        const pushToast = (tone, message) => {
          const id = Date.now() + Math.random();
          setToasts(prev => [...prev, { id, tone, message }]);
          setTimeout(() => {
            setToasts(prev => prev.filter(toast => toast.id !== id));
          }, 4200);
        };

        const dismissToast = id => {
          setToasts(prev => prev.filter(toast => toast.id !== id));
        };

        const normalizeConfig = cfg => ({
          inspectMode: (cfg && cfg.inspectMode) || '',
          requestForwardMode: (cfg && cfg.requestForwardMode) || '',
          redactMode: (cfg && cfg.redactMode) || '',
          logLevel: (cfg && cfg.logLevel) || '',
          requestExtractors: (cfg && Array.isArray(cfg.requestExtractors) ? cfg.requestExtractors : []),
          responseExtractors: (cfg && Array.isArray(cfg.responseExtractors) ? cfg.responseExtractors : []),
          extractorParallelEnabled: !!(cfg && cfg.extractorParallelEnabled)
        });

        const isDirty = useMemo(() => {
          if (!config || !serverConfig) return false;
          return JSON.stringify(normalizeConfig(config)) !== JSON.stringify(normalizeConfig(serverConfig));
        }, [config, serverConfig]);

        const derivedOptions = useMemo(() => ({
          inspectMode: options.inspectMode || [],
          requestForwardMode: options.requestForwardMode || [],
          redactMode: options.redactMode || [],
          logLevel: options.logLevel || []
        }), [options]);

        const patternMaps = useMemo(() => {
          const contextMap = { request: [], response: [] };
          const byId = new Map();
          patterns.forEach(pattern => {
            if (!pattern || !pattern.id) return;
            byId.set(pattern.id, pattern);
            if (pattern.context === 'request') {
              contextMap.request.push(pattern);
            } else if (pattern.context === 'response') {
              contextMap.response.push(pattern);
            }
          });
          return { contextMap, byId };
        }, [patterns]);

        const requestExtractorIds = useMemo(() => (
          config && Array.isArray(config.requestExtractors) ? config.requestExtractors : []
        ), [config]);
        const responseExtractorIds = useMemo(() => (
          config && Array.isArray(config.responseExtractors) ? config.responseExtractors : []
        ), [config]);
        const requestPatternSelections = useMemo(
          () => requestExtractorIds.map(id => patternMaps.byId.get(id)).filter(Boolean),
          [requestExtractorIds, patternMaps]
        );
        const responsePatternSelections = useMemo(
          () => responseExtractorIds.map(id => patternMaps.byId.get(id)).filter(Boolean),
          [responseExtractorIds, patternMaps]
        );
        const extractorParallelEnabled = !!(config && config.extractorParallelEnabled);
        const effectiveRedactMode = useMemo(() => computeEffectiveRedactMode(config), [config]);
        const redactionConstraints = useMemo(() => describeRedactionConstraints(config), [config]);

        const registerSection = id => el => {
          if (el) {
            sectionRefs.current[id] = el;
          }
        };

        const navigateTo = id => {
          const element = sectionRefs.current[id];
          if (element) {
            element.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        };

        const attachScrollSpy = () => {
          const observer = new IntersectionObserver(
            entries => {
              const visible = entries.filter(entry => entry.isIntersecting).sort((a, b) => b.intersectionRatio - a.intersectionRatio);
              if (visible.length) {
                setActiveSection(visible[0].target.id);
              }
            },
            {
              rootMargin: '-40% 0px -55% 0px',
              threshold: [0.1, 0.35, 0.6]
            }
          );
          NAV_SECTIONS.forEach(item => {
            const el = sectionRefs.current[item.id];
            if (el) observer.observe(el);
          });
          return () => observer.disconnect();
        };

        useEffect(() => {
          if (!config) return;
          const detach = attachScrollSpy();
          return detach;
        }, [config]);

        const fetchConfig = async hostOverride => {
          const targetHost = normalizeHost(hostOverride || selectedHost);
          try {
            setStatus({ tone: 'loading', message: `Loading configuration for ${hostDisplayLabel(targetHost)}…` });
            const response = await fetch('/config/api', {
              headers: {
                Accept: 'application/json',
                'X-Guardrails-Config-Host': targetHost
              }
            });
            if (!response.ok) {
              throw new Error(`Request failed with status ${response.status}`);
            }
            const payload = await response.json();
            const serverHost = normalizeHost(payload.host || targetHost);
            const hostList = Array.isArray(payload.hosts) && payload.hosts.length
              ? payload.hosts.map(normalizeHost)
              : [DEFAULT_HOST];
            const hydratedConfig = hydrateConfig(payload.config);
            const hydratedDefaults = hydrateConfig(payload.defaults || {});
            setHosts(hostList);
            setSelectedHost(serverHost);
            setConfig(hydratedConfig);
            setServerConfig(hydratedConfig);
            setDefaults(hydratedDefaults);
            setOptions(payload.options || {});
            setUpdatedAt(new Date());
            const message = `Configuration loaded for ${hostDisplayLabel(serverHost)}.`;
            setStatus({ tone: 'success', message });
            pushToast('success', message);
          } catch (error) {
            const message = `Unable to load configuration: ${error.message}`;
            setStatus({ tone: 'error', message });
            pushToast('error', message);
            if (targetHost !== DEFAULT_HOST) {
              const fallbackHost = DEFAULT_HOST;
              setSelectedHost(fallbackHost);
              persistSelectedHost(fallbackHost);
              setTimeout(() => {
                fetchConfig(fallbackHost);
              }, 0);
            }
          }
        };

        const fetchPatterns = async () => {
          try {
            const response = await fetch('/config/api/patterns', {
              headers: { Accept: 'application/json' }
            });
            if (!response.ok) {
              throw new Error(`Request failed with status ${response.status}`);
            }
            const payload = await response.json();
            setPatterns(Array.isArray(payload.items) ? payload.items : []);
          } catch (error) {
            pushToast('error', `Unable to load pattern rules: ${error.message}`);
          }
        };

        useEffect(() => {
          const persistedHost = readPersistedHost();
          const targetHost = persistedHost || DEFAULT_HOST;
          setSelectedHost(targetHost);
          fetchConfig(targetHost);
          fetchPatterns();
        }, []);

        useEffect(() => {
          if (!hasSyncedHostRef.current) {
            hasSyncedHostRef.current = true;
            return;
          }
          persistSelectedHost(selectedHost);
        }, [selectedHost]);

        const handleSelectChange = (key, value) => {
          setConfig(prev => ({ ...prev, [key]: value }));
          if (key === 'requestForwardMode') {
            if (value === 'parallel') {
              pushToast('info', 'Parallel forwarding disables request redaction during inspection.');
            } else {
              pushToast('info', 'Sequential forwarding respects your configured request redaction.');
            }
          }
        };

        const handlePatternToggle = (context, patternId, checked) => {
          const key = context === 'response' ? 'responseExtractors' : 'requestExtractors';
          setConfig(prev => {
            const current = prev && Array.isArray(prev[key]) ? prev[key] : [];
            let next = current;
            if (checked) {
              if (current.indexOf(patternId) === -1) {
                next = [...current, patternId];
              }
            } else {
              next = current.filter(id => id !== patternId);
            }
            return { ...prev, [key]: next };
          });
        };

        const handleParallelToggle = enabled => {
          setConfig(prev => ({
            ...prev,
            extractorParallelEnabled: enabled
          }));
          if (enabled) {
            pushToast('info', 'Parallel extractor mode enabled; redaction pauses for affected directions.');
          } else {
            pushToast('info', 'Sequential extractor mode restored; redaction follows your selection.');
          }
        };

        const resetToDefaults = () => {
          if (!defaults) return;
          setConfig({
            inspectMode: defaults.inspectMode,
            requestForwardMode: defaults.requestForwardMode,
            redactMode: defaults.redactMode,
            logLevel: defaults.logLevel,
            requestExtractors: [...(defaults.requestExtractors || [])],
            responseExtractors: [...(defaults.responseExtractors || [])],
            extractorParallelEnabled: !!defaults.extractorParallelEnabled
          });
          const message = `Defaults staged for ${hostDisplayLabel(selectedHost)}. Save to persist.`;
          setStatus({ tone: 'info', message });
          pushToast('info', message);
        };

        const saveConfig = async event => {
          event.preventDefault();
          if (!config) return;
          if (!isDirty) {
            const message = `No changes detected for ${hostDisplayLabel(selectedHost)}.`;
            setStatus({ tone: 'info', message });
            pushToast('info', message);
            return;
          }
          setSaving(true);
          setStatus({ tone: 'loading', message: `Saving ${hostDisplayLabel(selectedHost)}…` });
          const requestExtractors = Array.isArray(config.requestExtractors)
            ? config.requestExtractors.map(item => String(item).trim()).filter(Boolean)
            : [];
          const responseExtractors = Array.isArray(config.responseExtractors)
            ? config.responseExtractors.map(item => String(item).trim()).filter(Boolean)
            : [];
          const redactModePayload = config.redactMode && String(config.redactMode).trim() ? config.redactMode : 'off';
          const payload = {
            inspectMode: config.inspectMode,
            requestForwardMode: config.requestForwardMode,
            redactMode: redactModePayload,
            logLevel: config.logLevel,
            requestExtractors,
            responseExtractors,
            extractorParallelEnabled: !!config.extractorParallelEnabled
          };
          try {
            const response = await fetch('/config/api', {
              method: 'PATCH',
              headers: {
                'Content-Type': 'application/json',
                Accept: 'application/json',
                'X-Guardrails-Config-Host': selectedHost
              },
              body: JSON.stringify(payload)
            });
            if (!response.ok) {
              const errPayload = await response.json().catch(() => ({}));
              const message = errPayload.errors ? errPayload.errors.join('; ') : errPayload.message || `Request failed (${response.status})`;
              throw new Error(message);
            }
            const data = await response.json();
            const hydrated = hydrateConfig(data.config);
            const hydratedDefaults = hydrateConfig(data.defaults || defaults || {});
            setConfig(hydrated);
            setServerConfig(hydrated);
            setDefaults(hydratedDefaults);
            setOptions(data.options || options);
            setHosts(Array.isArray(data.hosts) && data.hosts.length ? data.hosts.map(normalizeHost) : hosts);
            setUpdatedAt(new Date());
            const message = `Configuration saved for ${hostDisplayLabel(selectedHost)}.`;
            setStatus({ tone: 'success', message });
            pushToast('success', message);
          } catch (error) {
            const message = `Save failed: ${error.message}`;
            setStatus({ tone: 'error', message });
            pushToast('error', message);
          } finally {
            setSaving(false);
          }
        };

        const handleHostSelect = host => {
          const normalized = normalizeHost(host);
          if (normalized === selectedHost) return;
          setSelectedHost(normalized);
          fetchConfig(normalized);
        };

        const createHost = async () => {
          const raw = window.prompt('Enter the Host header value for the new configuration');
          if (raw === null) return;
          const normalized = normalizeHost(raw);
          if (!raw.trim()) {
            pushToast('info', 'Host value cannot be empty.');
            return;
          }
          if (hosts.indexOf(normalized) !== -1) {
            pushToast('info', `${hostDisplayLabel(normalized)} already exists.`);
            return;
          }
          try {
            setStatus({ tone: 'loading', message: `Creating ${hostDisplayLabel(normalized)}…` });
            const response = await fetch('/config/api', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                Accept: 'application/json',
                'X-Guardrails-Config-Host': normalized
              },
              body: JSON.stringify({ host: normalized })
            });
            if (!response.ok) {
              const errPayload = await response.json().catch(() => ({}));
              const message = errPayload.message || (errPayload.errors && errPayload.errors.join('; ')) || `Request failed (${response.status})`;
              throw new Error(message);
            }
            const data = await response.json();
            const serverHost = normalizeHost(data.host || normalized);
            const hydratedConfig = hydrateConfig(data.config);
            const hydratedDefaults = hydrateConfig(data.defaults || defaults || {});
            setHosts(Array.isArray(data.hosts) && data.hosts.length ? data.hosts.map(normalizeHost) : [DEFAULT_HOST]);
            setSelectedHost(serverHost);
            setConfig(hydratedConfig);
            setServerConfig(hydratedConfig);
            setDefaults(hydratedDefaults);
            setOptions(data.options || options);
            setUpdatedAt(new Date());
            const message = `Created ${hostDisplayLabel(serverHost)}.`;
            setStatus({ tone: 'success', message });
            pushToast('success', message);
          } catch (error) {
            const message = `Create failed: ${error.message}`;
            setStatus({ tone: 'error', message });
            pushToast('error', message);
          }
        };

        const deleteHost = async hostValue => {
          const target = normalizeHost(hostValue || selectedHost);
          if (target === DEFAULT_HOST) {
            pushToast('info', 'The default host cannot be removed.');
            return;
          }
          if (!window.confirm(`Remove configuration for ${hostDisplayLabel(target)}?`)) {
            return;
          }
          try {
            setStatus({ tone: 'loading', message: `Removing ${hostDisplayLabel(target)}…` });
            const response = await fetch('/config/api', {
              method: 'DELETE',
              headers: {
                'Content-Type': 'application/json',
                Accept: 'application/json',
                'X-Guardrails-Config-Host': target
              },
              body: JSON.stringify({ host: target })
            });
            if (!response.ok) {
              const errPayload = await response.json().catch(() => ({}));
              const message = errPayload.message || (errPayload.errors && errPayload.errors.join('; ')) || `Request failed (${response.status})`;
              throw new Error(message);
            }
            const data = await response.json();
            const nextHost = normalizeHost(data.host || DEFAULT_HOST);
            const hydratedConfig = hydrateConfig(data.config);
            const hydratedDefaults = hydrateConfig(data.defaults || defaults || {});
            setHosts(Array.isArray(data.hosts) && data.hosts.length ? data.hosts.map(normalizeHost) : [DEFAULT_HOST]);
            setSelectedHost(nextHost);
            setConfig(hydratedConfig);
            setServerConfig(hydratedConfig);
            setDefaults(hydratedDefaults);
            setOptions(data.options || options);
            setUpdatedAt(new Date());
            const message = `Removed ${hostDisplayLabel(target)}.`;
            setStatus({ tone: 'success', message });
            pushToast('success', message);
          } catch (error) {
            const message = `Delete failed: ${error.message}`;
            setStatus({ tone: 'error', message });
            pushToast('error', message);
          }
        };

        const statusSummary = useMemo(() => {
          if (!config) return '—';
          const hostLabel = hostDisplayLabel(selectedHost);
          return updatedAt ? `${hostLabel} last updated ${updatedAt.toLocaleString()}` : hostLabel;
        }, [config, updatedAt, selectedHost]);

        if (!config || !defaults) {
          return (
            <>
              <TopNavigation current="config" />
              <div className="grid gap-8 lg:grid-cols-[280px_1fr]">
              <div className="space-y-4">
                <div className="h-64 rounded-3xl bg-white/70 shadow-sm" />
              </div>
              <div className="space-y-6">
                <StatusBanner status={status} />
                <div className="grid gap-6 sm:grid-cols-2">
                  {[...Array(4)].map((_, index) => (
                    <div key={index} className="h-48 animate-pulse rounded-3xl bg-white shadow-sm"></div>
                  ))}
                </div>
              </div>
            </div>
            </>
          );
        }

        return (
          <>
            <TopNavigation current="config" />
            <ToastStack toasts={toasts} dismiss={dismissToast} />
            <form onSubmit={saveConfig} className="grid gap-8 lg:grid-cols-[280px_1fr]">
              <StickyNav activeSection={activeSection} onNavigate={navigateTo} isDirty={isDirty} />
              <div className="space-y-10">
                <SectionCard
                  ref={registerSection('overview')}
                  id="overview"
                  title="Current Snapshot"
                  description={statusSummary}
                >
                  <HostSelector
                    hosts={hosts}
                    selectedHost={selectedHost}
                    onSelect={handleHostSelect}
                    onCreate={createHost}
                    onDelete={deleteHost}
                  />
                  <StatusBanner status={status} />
                  <SummaryChips config={config} />
                </SectionCard>

                <SectionCard
                  ref={registerSection('inspection')}
                  id="inspection"
                  title="Inspection Modes"
                  description="Control which message directions are screened by the guardrails service."
                >
                  <SelectField
                    label="Inspection Mode"
                    helper="Select which portions of the conversation are inspected (request, response, or both)."
                    options={derivedOptions.inspectMode}
                    value={config.inspectMode}
                    onChange={value => handleSelectChange('inspectMode', value)}
                  />
                  <SelectField
                    label="Request Forwarding"
                    helper="Sequential waits for scan results and works with request redaction. Parallel dispatches upstream immediately and pauses request redaction during inspection."
                    options={derivedOptions.requestForwardMode}
                    value={config.requestForwardMode}
                    onChange={value => handleSelectChange('requestForwardMode', value)}
                  />
                </SectionCard>

                <SectionCard
                  ref={registerSection('extraction')}
                  id="extraction"
                  title="Extraction Profiles"
                  description="Select which patterns supply extraction selectors and API keys."
                >
                  <div className="flex items-center justify-between gap-3 rounded-2xl border border-slate-200 bg-slate-50/70 px-4 py-3">
                    <div>
                      <p className="text-sm font-semibold text-slate-700">Parallel extractor mode</p>
                      <p className="text-xs text-slate-500">
                        When enabled, all matching profiles run per stage without redaction. Disable to evaluate profiles sequentially and allow redaction.
                      </p>
                    </div>
                    <label className="inline-flex items-center gap-2 text-sm font-medium text-slate-700">
                      <input
                        type="checkbox"
                        className="h-4 w-4 rounded border-slate-300 text-primary focus:ring-primary"
                        checked={extractorParallelEnabled}
                        onChange={event => handleParallelToggle(event.target.checked)}
                      />
                      Parallel
                    </label>
                  </div>

                  <PatternMultiSelector
                    label="Request Extraction Profiles"
                    helper="Selected profiles supply their own selectors and API keys."
                    note={extractorParallelEnabled
                      ? 'All selected request profiles execute in parallel; request redaction is skipped while this mode is active.'
                      : 'Profiles evaluate in selection order; the first match determines the scan.'}
                    patterns={patternMaps.contextMap.request}
                    values={requestExtractorIds}
                    onToggle={(patternId, checked) => handlePatternToggle('request', patternId, checked)}
                  />

                  <PatternMultiSelector
                    label="Response Extraction Profiles"
                    helper="Select patterns that control response extraction and API keys."
                    note={extractorParallelEnabled
                      ? 'All selected response profiles execute in parallel; response redaction is skipped while this mode is active.'
                      : 'Profiles evaluate in selection order; the first match determines the scan.'}
                    patterns={patternMaps.contextMap.response}
                    values={responseExtractorIds}
                    onToggle={(patternId, checked) => handlePatternToggle('response', patternId, checked)}
                  />
                </SectionCard>

                <SectionCard
                  ref={registerSection('telemetry')}
                  id="telemetry"
                  title="Redaction & Logging"
                  description="Configure automatic masking behavior and the verbosity of NJS logs."
                >
                  <SelectField
                    label="Redaction Mode"
                    helper={redactionConstraints
                      ? `${redactionConstraints} Effective redaction: ${effectiveRedactMode}.`
                      : `Effective redaction: ${effectiveRedactMode}. Choose request, response, both, or off.`}
                    options={derivedOptions.redactMode}
                    value={config.redactMode}
                    onChange={value => handleSelectChange('redactMode', value)}
                  />
                  <SelectField
                    label="Log Level"
                    helper="Choose how verbose the guardrails handler should be in the NGINX error log."
                    options={derivedOptions.logLevel}
                    value={config.logLevel}
                    onChange={value => handleSelectChange('logLevel', value)}
                  />
                </SectionCard>

                <div className="sticky bottom-4 z-40 rounded-3xl border border-slate-200 bg-white/95 p-4 shadow-xl backdrop-blur">
                  <div className="flex flex-col gap-4 md:flex-row md:items-center md:justify-between">
                    <div>
                      <p className="text-sm font-semibold text-slate-700">Ready to apply your updates?</p>
                      <p className="text-xs text-slate-500">Changes persist to the key-value store immediately after saving.</p>
                    </div>
                    <div className="flex flex-col gap-3 sm:flex-row">
                      <button
                        type="button"
                        onClick={resetToDefaults}
                        className="inline-flex justify-center rounded-lg border border-slate-300 px-4 py-2 text-sm font-medium text-slate-600 hover:bg-slate-100"
                      >
                        Reset to Defaults
                      </button>
                      <button
                        type="button"
                        onClick={() => {
                          fetchConfig(selectedHost);
                          fetchPatterns();
                        }}
                        className="inline-flex justify-center rounded-lg border border-slate-300 px-4 py-2 text-sm font-medium text-slate-600 hover:bg-slate-100"
                      >
                        Refresh from Server
                      </button>
                      <button
                        type="submit"
                        className={`inline-flex justify-center rounded-lg bg-blue-600 px-6 py-2 text-sm font-semibold text-white shadow hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 ${isDirty ? '' : 'opacity-60'}`}
                        aria-disabled={!isDirty}
                        disabled={saving || !isDirty}
                      >
                        {saving ? 'Saving…' : 'Save Changes'}
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </form>
          </>
        );
      };

      const STATUS_TONES = {
        success: 'border-emerald-200 bg-emerald-50 text-emerald-700',
        error: 'border-rose-200 bg-rose-50 text-rose-700',
        info: 'border-sky-200 bg-sky-50 text-sky-700',
        muted: 'border-slate-200 bg-white text-slate-600'
      };

      const VIEW_OPTIONS = [
        { id: 'config', label: 'Scan Configuration' },
        { id: 'collector', label: 'Payload Collector' }
      ];

      function classNames(...parts) {
        return parts.filter(Boolean).join(' ');
      }

      function useAsyncCallback(callback) {
        const [pending, setPending] = useState(false);
        const wrapped = async (...args) => {
          if (pending) return;
          setPending(true);
          try {
            return await callback(...args);
          } finally {
            setPending(false);
          }
        };
        return [wrapped, pending];
      }

      const SummaryPill = ({ label, value }) => (
        <div className="flex flex-col rounded-2xl border border-slate-200 bg-white px-4 py-3 shadow-sm">
          <span className="text-xs uppercase tracking-wide text-slate-500">{label}</span>
          <span className="mt-1 text-lg font-semibold text-slate-800">{value}</span>
        </div>
      );

      function TreeNode({ name, value, path, depth = 0, onSelect }) {
        const isObject = value && typeof value === 'object';
        const isArray = Array.isArray(value);
        const hasChildren = isObject || isArray;
        const [open, setOpen] = useState(depth < 1);

        const preview = useMemo(() => {
          if (value === null) return 'null';
          if (isArray) return `Array(${value.length})`;
          if (isObject) return 'Object';
          if (typeof value === 'string') {
            return `"${value.length > 40 ? value.slice(0, 37) + '…' : value}"`;
          }
          return String(value);
        }, [value, isArray, isObject]);

        const toggle = event => {
          event.stopPropagation();
          setOpen(prev => !prev);
        };

        const handleSelect = event => {
          event.stopPropagation();
          if (onSelect && path) {
            onSelect(path);
          }
        };

        return (
          <div className="ml-4">
            <div
              className={classNames(
                'group flex items-center gap-2 rounded-md px-2 py-1 text-sm transition',
                'hover:bg-slate-100'
              )}
            >
              {hasChildren ? (
                <button
                  type="button"
                  onClick={toggle}
                  className="h-5 w-5 rounded border border-slate-300 text-xs text-slate-600 hover:border-slate-400 hover:text-slate-800"
                  aria-label={open ? 'Collapse node' : 'Expand node'}
                >
                  {open ? '−' : '+'}
                </button>
              ) : (
                <span className="inline-flex h-5 w-5 items-center justify-center text-slate-300">•</span>
              )}
              <button
                type="button"
                onClick={handleSelect}
                className="flex-1 text-left font-mono text-xs text-slate-700 group-hover:text-primary"
              >
                <span className="font-semibold text-slate-800">{name}</span>
                <span className="ml-2 text-slate-500">{preview}</span>
              </button>
            </div>
            {hasChildren && open ? (
              <div className="border-l border-dashed border-slate-300 pl-4">
                {isArray
                  ? value.map((item, index) => {
                      const childPath = path ? `${path}[${index}]` : `.[${index}]`;
                      return (
                        <TreeNode
                          key={childPath}
                          name={`[${index}]`}
                          value={item}
                          path={childPath}
                          depth={depth + 1}
                          onSelect={onSelect}
                        />
                      );
                    })
                  : Object.keys(value).map(childKey => {
                      const childPath = path ? `${path}.${childKey}` : `.${childKey}`;
                      return (
                        <TreeNode
                          key={childPath}
                          name={childKey}
                          value={value[childKey]}
                          path={childPath}
                          depth={depth + 1}
                          onSelect={onSelect}
                        />
                      );
                    })}
              </div>
            ) : null}
          </div>
        );
      }

      function PayloadTree({ title, bodyText, onSelect }) {
        const parsed = useMemo(() => {
          if (!bodyText) return { kind: 'empty' };
          try {
            return { kind: 'json', value: JSON.parse(bodyText) };
          } catch (_) {
            return { kind: 'text' };
          }
        }, [bodyText]);

        const rootSelector = onSelect ? (path => onSelect(path || '.')) : undefined;

        return (
          <section className="space-y-3">
            <header className="flex items-center justify-between">
              <h3 className="text-sm font-semibold text-slate-700">{title}</h3>
              <span className="font-mono text-xs text-slate-500">{bodyText.length} bytes</span>
            </header>
            <div className="rounded-2xl border border-slate-200 bg-white/90 p-4 shadow-inner">
              {parsed.kind === 'json' ? (
                <div className="space-y-2">
                  {Array.isArray(parsed.value) ? (
                    <TreeNode
                      name="root"
                      value={parsed.value}
                      path=""
                      depth={0}
                      onSelect={rootSelector}
                    />
                  ) : typeof parsed.value === 'object' && parsed.value !== null ? (
                    Object.keys(parsed.value).length ? (
                      Object.keys(parsed.value).map(key => (
                        <TreeNode
                          key={`.${key}`}
                          name={key}
                          value={parsed.value[key]}
                          path={`.${key}`}
                          depth={0}
                          onSelect={onSelect}
                        />
                      ))
                    ) : (
                      <p className="text-sm text-slate-500">Object is empty.</p>
                    )
                  ) : (
                    <div className="text-sm text-slate-600">
                      Primitive: <span className="font-mono">{JSON.stringify(parsed.value)}</span>
                    </div>
                  )}
                </div>
              ) : parsed.kind === 'text' ? (
                <pre className="max-h-64 overflow-auto rounded bg-slate-900/90 p-3 text-xs text-slate-100">
{bodyText}
                </pre>
              ) : (
                <p className="text-sm text-slate-500">No payload captured for this entry.</p>
              )}
            </div>
          </section>
        );
      }

      const MAX_SELECTORS = 12;

      const DEFAULT_BLOCK_BODY_TEMPLATE = {
        message: {
          role: 'assistant',
          content: 'F5 AI Guardrails blocked this request'
        }
      };

      const DEFAULT_BLOCKING_RESPONSE_SHAPE = Object.freeze({
        status: 200,
        contentType: 'application/json; charset=utf-8',
        body: JSON.stringify(DEFAULT_BLOCK_BODY_TEMPLATE, null, 2)
      });

      function prettyPrintBlockingBody(value) {
        if (typeof value !== 'string') return '';
        const trimmed = value.trim();
        if (!trimmed) return '';
        try {
          const parsed = JSON.parse(trimmed);
          return JSON.stringify(parsed, null, 2);
        } catch (_) {
          return value;
        }
      }

      function normalizeBlockingResponseConfig(value) {
        const base = DEFAULT_BLOCKING_RESPONSE_SHAPE;
        let source = value;
        let fromDefault = false;

        if (!source || typeof source !== 'object') {
          source = {};
          fromDefault = true;
        } else if (source.__fromDefault === true) {
          fromDefault = true;
        }

        const result = {
          status: base.status,
          contentType: base.contentType,
          body: base.body
        };

        if (source.status !== undefined) {
          const num = Number(source.status);
          if (Number.isFinite(num) && num >= 100 && num <= 999) {
            result.status = Math.trunc(num);
          }
        }

        if (source.contentType !== undefined) {
          const ct = String(source.contentType).trim();
          if (ct) {
            result.contentType = ct;
          }
        }

        if (source.body !== undefined) {
          if (typeof source.body === 'string') {
            const pretty = prettyPrintBlockingBody(source.body);
            result.body = pretty === '' ? '' : pretty;
          } else if (source.body && typeof source.body === 'object') {
            try {
              result.body = JSON.stringify(source.body, null, 2);
            } catch (_) {
              result.body = base.body;
            }
          } else {
            result.body = '';
          }
        }

        result.__fromDefault = fromDefault;
        return result;
      }

      function summarizeBlockingResponseBody(response) {
        if (!response || typeof response !== 'object') return '—';
        const { body } = response;
        if (!body) return '—';
        if (typeof body !== 'string') {
          try {
            return JSON.stringify(body);
          } catch (_) {
            return '—';
          }
        }
        try {
          const parsed = JSON.parse(body);
          const message = parsed && parsed.message;
          if (message && typeof message.content === 'string') {
            return message.content.length > 80 ? `${message.content.slice(0, 80)}…` : message.content;
          }
        } catch (_) {
          // ignore parse failure
        }
        const trimmed = body.trim();
        if (!trimmed) return '—';
        return trimmed.length > 80 ? `${trimmed.slice(0, 80)}…` : trimmed;
      }

      function createEmptyEditorForm() {
        return {
          name: '',
          key: '',
          blockStatus: String(DEFAULT_BLOCKING_RESPONSE_SHAPE.status),
          blockContentType: DEFAULT_BLOCKING_RESPONSE_SHAPE.contentType,
          blockBody: DEFAULT_BLOCKING_RESPONSE_SHAPE.body
        };
      }

      function blockingResponsesEqual(a, b) {
        if (!a || !b) return false;
        return a.status === b.status && a.contentType === b.contentType && a.body === b.body;
      }

      const ApiKeysApp = () => {
        const [keys, setKeys] = useState([]);
        const [status, setStatus] = useState({ tone: 'loading', message: 'Loading API keys…' });
        const [toasts, setToasts] = useState([]);
        const [editorOpen, setEditorOpen] = useState(false);
        const [editorMode, setEditorMode] = useState('create');
        const [editingRecord, setEditingRecord] = useState(null);
        const [editorForm, setEditorForm] = useState(() => createEmptyEditorForm());
        const [editorSubmitting, setEditorSubmitting] = useState(false);

        const pushToast = (tone, message) => {
          const id = Date.now() + Math.random();
          setToasts(prev => [...prev, { id, tone, message }]);
          setTimeout(() => {
            setToasts(prev => prev.filter(toast => toast.id !== id));
          }, 4200);
        };

        const dismissToast = id => {
          setToasts(prev => prev.filter(toast => toast.id !== id));
        };

        const loadKeys = async () => {
          try {
            setStatus({ tone: 'loading', message: 'Loading API keys…' });
            const response = await fetch('/config/api/keys', {
              headers: { Accept: 'application/json' }
            });
            if (!response.ok) {
              throw new Error(`Request failed with status ${response.status}`);
            }
            const payload = await response.json();
            const items = Array.isArray(payload.items) ? payload.items : [];
            const normalized = items.map(item => ({
              ...item,
              blockingResponse: normalizeBlockingResponseConfig(item.blockingResponse)
            }));
            setKeys(normalized);
            setStatus({ tone: 'success', message: `Loaded ${normalized.length} API key${normalized.length === 1 ? '' : 's'}.` });
          } catch (error) {
            const message = `Unable to load API keys: ${error.message}`;
            setStatus({ tone: 'error', message });
            pushToast('error', message);
          }
        };

        useEffect(() => {
          loadKeys();
        }, []);

        const keyPreview = value => {
          if (!value) return '—';
          const trimmed = String(value).trim();
          if (trimmed.length <= 8) return trimmed;
          return `${trimmed.slice(0, 4)}…${trimmed.slice(-4)}`;
        };

        const resetEditor = () => {
          setEditorForm(createEmptyEditorForm());
          setEditingRecord(null);
          setEditorMode('create');
        };

        const closeEditor = () => {
          setEditorOpen(false);
          resetEditor();
        };

        const openCreate = () => {
          setEditorMode('create');
          setEditingRecord(null);
          setEditorForm(createEmptyEditorForm());
          setEditorOpen(true);
        };

        const openEdit = record => {
          if (!record) return;
          const normalizedBlock = normalizeBlockingResponseConfig(record.blockingResponse);
          setEditorMode('edit');
          setEditingRecord(record);
          setEditorForm({
            name: record.name || '',
            key: '',
            blockStatus: String(normalizedBlock.status),
            blockContentType: normalizedBlock.contentType,
            blockBody: normalizedBlock.body
          });
          setEditorOpen(true);
        };

        const handleEditorChange = event => {
          const { name, value } = event.target;
          setEditorForm(prev => ({ ...prev, [name]: value }));
        };

        const buildBlockingPayload = () => {
          const statusNumber = Number(editorForm.blockStatus);
          if (!Number.isFinite(statusNumber)) {
            pushToast('info', 'Blocking status must be a number between 100 and 999.');
            return null;
          }
          const statusCode = Math.trunc(statusNumber);
          if (statusCode < 100 || statusCode > 999) {
            pushToast('info', 'Blocking status must be between 100 and 999.');
            return null;
          }
          const contentType = (editorForm.blockContentType || '').trim();
          if (!contentType) {
            pushToast('info', 'Blocking response content type cannot be empty.');
            return null;
          }
          const body = editorForm.blockBody === undefined || editorForm.blockBody === null
            ? ''
            : String(editorForm.blockBody);
          return { status: statusCode, contentType, body };
        };

        const handleEditorSubmit = async event => {
          event.preventDefault();
          const name = (editorForm.name || '').trim();
          const key = (editorForm.key || '').trim();

          if (!name) {
            pushToast('info', 'Display name is required.');
            return;
          }

          if (editorMode === 'create' && !key) {
            pushToast('info', 'Provide an API key value.');
            return;
          }

          const blockingPayload = buildBlockingPayload();
          if (!blockingPayload) {
            return;
          }

          setEditorSubmitting(true);
          try {
            if (editorMode === 'create') {
              const response = await fetch('/config/api/keys', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', Accept: 'application/json' },
                body: JSON.stringify({ name, key, blockingResponse: blockingPayload })
              });
              if (!response.ok) {
                const data = await response.json().catch(() => ({}));
                throw new Error(data.message || data.error || `Request failed (${response.status})`);
              }
              pushToast('success', `API key “${name}” saved.`);
              closeEditor();
              await loadKeys();
            } else if (editingRecord && editingRecord.id) {
              const payload = { id: editingRecord.id };
              let changed = false;
              if (name !== editingRecord.name) {
                payload.name = name;
                changed = true;
              }
              if (key) {
                payload.key = key;
                changed = true;
              }
              const existingBlocking = editingRecord.blockingResponse || normalizeBlockingResponseConfig(null);
              if (!blockingResponsesEqual(blockingPayload, existingBlocking) || existingBlocking.__fromDefault === true) {
                payload.blockingResponse = blockingPayload;
                changed = true;
              }
              if (!changed) {
                pushToast('info', 'Update at least one field before saving.');
                return;
              }
              const response = await fetch('/config/api/keys', {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json', Accept: 'application/json' },
                body: JSON.stringify(payload)
              });
              if (!response.ok) {
                const data = await response.json().catch(() => ({}));
                throw new Error(data.message || data.error || `Request failed (${response.status})`);
              }
              pushToast('success', `API key “${name}” updated.`);
              closeEditor();
              await loadKeys();
            } else {
              throw new Error('Missing API key identifier.');
            }
          } catch (error) {
            pushToast('error', `Save failed: ${error.message}`);
          } finally {
            setEditorSubmitting(false);
          }
        };

        const handleDelete = async record => {
          if (!record || !record.id) return;
          const confirmed = window.confirm(`Delete API key “${record.name}”? This cannot be undone.`);
          if (!confirmed) return;
          try {
            const response = await fetch('/config/api/keys', {
              method: 'DELETE',
              headers: { 'Content-Type': 'application/json', Accept: 'application/json' },
              body: JSON.stringify({ id: record.id })
            });
            if (!response.ok) {
              const data = await response.json().catch(() => ({}));
              throw new Error(data.message || data.error || `Request failed (${response.status})`);
            }
            pushToast('success', `API key “${record.name}” removed.`);
            await loadKeys();
          } catch (error) {
            pushToast('error', `Delete failed: ${error.message}`);
          }
        };

        return (
          <>
            <TopNavigation current="keys" />
            <ToastStack toasts={toasts} dismiss={dismissToast} />
            <StatusBanner status={status} />
            <div className="mt-6 space-y-5 rounded-3xl border border-slate-200 bg-white/90 p-6 shadow-sm">
              <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
                <div>
                  <h2 className="text-lg font-semibold text-slate-800">Configured Keys</h2>
                  <p className="text-sm text-slate-500">These keys can be referenced by pattern rules on the matching page.</p>
                </div>
                <div className="flex gap-2">
                  <button
                    type="button"
                    onClick={loadKeys}
                    className="rounded-lg border border-slate-300 px-3 py-1.5 text-sm font-medium text-slate-600 hover:bg-slate-100"
                  >
                    Refresh
                  </button>
                  <button
                    type="button"
                    onClick={openCreate}
                    className="rounded-lg bg-blue-600 px-3 py-1.5 text-sm font-semibold text-white shadow hover:bg-blue-700"
                  >
                    New Key
                  </button>
                </div>
              </div>

              {keys.length === 0 ? (
                <div className="rounded-2xl border border-dashed border-slate-300 bg-slate-50 px-4 py-12 text-center text-sm text-slate-500">
                  No API keys configured yet.
                </div>
              ) : (
                <div className="overflow-hidden rounded-2xl border border-slate-200">
                  <table className="min-w-full divide-y divide-slate-200 text-sm">
                    <thead className="bg-slate-50 text-slate-600">
                      <tr>
                        <th className="px-4 py-3 text-left font-semibold">Name</th>
                        <th className="px-4 py-3 text-left font-semibold">Key Preview</th>
                        <th className="px-4 py-3 text-left font-semibold">Blocking Response</th>
                        <th className="px-4 py-3 text-left font-semibold">Updated</th>
                        <th className="px-4 py-3 text-right font-semibold">Actions</th>
                      </tr>
                    </thead>
                    <tbody className="divide-y divide-slate-100 bg-white">
                      {keys.map(record => (
                        <tr key={record.id}>
                          <td className="px-4 py-3 font-medium text-slate-800">{record.name}</td>
                          <td className="px-4 py-3 font-mono text-xs text-slate-600">{keyPreview(record.key)}</td>
                          <td className="px-4 py-3 text-slate-500">
                            <div className="flex items-center gap-2 text-xs text-slate-600">
                              <span className="font-semibold text-slate-700">{(record.blockingResponse && record.blockingResponse.status) || DEFAULT_BLOCKING_RESPONSE_SHAPE.status}</span>
                              <span className="text-slate-400">•</span>
                              <span>{(record.blockingResponse && record.blockingResponse.contentType) || DEFAULT_BLOCKING_RESPONSE_SHAPE.contentType}</span>
                            </div>
                            <div className="mt-1 truncate text-xs text-slate-500">
                              {summarizeBlockingResponseBody(record.blockingResponse)}
                            </div>
                          </td>
                          <td className="px-4 py-3 text-slate-500">{record.updated_at ? new Date(record.updated_at).toLocaleString() : '—'}</td>
                          <td className="flex justify-end gap-2 px-4 py-3 text-right">
                            <button
                              type="button"
                              onClick={() => openEdit(record)}
                              className="rounded-md border border-slate-300 px-3 py-1 text-xs font-medium text-slate-600 hover:bg-slate-100"
                            >
                              Edit
                            </button>
                            <button
                              type="button"
                              onClick={() => handleDelete(record)}
                              className="rounded-md border border-rose-200 px-3 py-1 text-xs font-medium text-rose-600 hover:bg-rose-50"
                            >
                              Delete
                            </button>
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              )}
            </div>

            <Modal
              open={editorOpen}
              title={editorMode === 'create' ? 'New API Key' : `Edit ${editingRecord ? editingRecord.name : 'API Key'}`}
              description={
                editorMode === 'create'
                  ? 'Provide a display name, bearer token, and customize the blocking response stored in the key-value store.'
                  : 'Update the display name, rotate the stored key value, or adjust the blocking response.'
              }
              onClose={() => {
                if (!editorSubmitting) {
                  closeEditor();
                }
              }}
            >
              <form onSubmit={handleEditorSubmit} className="space-y-4">
                <div className="space-y-2">
                  <label className="block text-sm font-medium text-slate-700" htmlFor="api-key-name">
                    Display Name
                  </label>
                  <input
                    id="api-key-name"
                    name="name"
                    type="text"
                    className="w-full rounded-lg border border-slate-300 px-3 py-2 text-sm focus:border-primary focus:ring-primary"
                    value={editorForm.name}
                    onChange={handleEditorChange}
                    placeholder="Production sideband token"
                    disabled={editorSubmitting}
                  />
                </div>
                <div className="space-y-2">
                  <label className="block text-sm font-medium text-slate-700" htmlFor="api-key-value">
                    API Key
                  </label>
                  <textarea
                    id="api-key-value"
                    name="key"
                    rows="3"
                    className="w-full rounded-lg border border-slate-300 px-3 py-2 text-sm focus:border-primary focus:ring-primary"
                    value={editorForm.key}
                    onChange={handleEditorChange}
                    placeholder={editorMode === 'create' ? 'Paste bearer token' : 'Leave blank to keep the current value'}
                    disabled={editorSubmitting}
                    required={editorMode === 'create'}
                  ></textarea>
                  <p className="text-xs text-slate-500">
                    {editorMode === 'create'
                      ? 'Values persist to the NGINX key-value store. Rotate credentials when upstream keys change.'
                      : 'Leaving this field blank keeps the currently stored token.'}
                  </p>
                </div>
                <div className="grid gap-4 sm:grid-cols-2">
                  <div className="space-y-2">
                    <label className="block text-sm font-medium text-slate-700" htmlFor="block-status">
                      Blocking Status Code
                    </label>
                    <input
                      id="block-status"
                      name="blockStatus"
                      type="number"
                      min="100"
                      max="999"
                      className="w-full rounded-lg border border-slate-300 px-3 py-2 text-sm focus:border-primary focus:ring-primary"
                      value={editorForm.blockStatus}
                      onChange={handleEditorChange}
                      placeholder="200"
                      disabled={editorSubmitting}
                    />
                    <p className="text-xs text-slate-500">Set the HTTP status returned when this key blocks a request.</p>
                  </div>
                  <div className="space-y-2">
                    <label className="block text-sm font-medium text-slate-700" htmlFor="block-content-type">
                      Blocking Content-Type
                    </label>
                    <input
                      id="block-content-type"
                      name="blockContentType"
                      type="text"
                      className="w-full rounded-lg border border-slate-300 px-3 py-2 text-sm focus:border-primary focus:ring-primary"
                      value={editorForm.blockContentType}
                      onChange={handleEditorChange}
                      placeholder="application/json; charset=utf-8"
                      disabled={editorSubmitting}
                    />
                    <p className="text-xs text-slate-500">Customize the Content-Type header attached to blocking responses.</p>
                  </div>
                </div>
                <div className="space-y-2">
                  <label className="block text-sm font-medium text-slate-700" htmlFor="block-body">
                    Blocking Response Body
                  </label>
                  <textarea
                    id="block-body"
                    name="blockBody"
                    rows="6"
                    className="w-full rounded-lg border border-slate-300 px-3 py-2 text-sm focus:border-primary focus:ring-primary"
                    value={editorForm.blockBody || ''}
                    onChange={handleEditorChange}
                    placeholder='{"message":{"role":"assistant","content":"F5 AI Guardrails blocked this request"}}'
                    disabled={editorSubmitting}
                  ></textarea>
                  <p className="text-xs text-slate-500">Provide the exact payload returned when a request is blocked. JSON is recommended.</p>
                </div>
                <div className="flex justify-end gap-3 pt-2">
                  <button
                    type="button"
                    className="rounded-md border border-slate-300 px-4 py-2 text-sm font-medium text-slate-600 hover:bg-slate-100 disabled:opacity-60"
                    onClick={() => {
                      if (!editorSubmitting) {
                        closeEditor();
                      }
                    }}
                    disabled={editorSubmitting}
                  >
                    Cancel
                  </button>
                  <button
                    type="submit"
                    className="rounded-md bg-blue-600 px-4 py-2 text-sm font-semibold text-white shadow hover:bg-blue-700 disabled:opacity-60"
                    disabled={editorSubmitting}
                  >
                    {editorSubmitting ? 'Saving…' : editorMode === 'create' ? 'Save Key' : 'Save Changes'}
                  </button>
                </div>
              </form>
            </Modal>
          </>
        );
      };

      const PatternsApp = () => {
        const emptyForm = {
          name: '',
          context: 'request',
          apiKeyName: '',
          paths: '',
          matchers: ''
        };
        const [patterns, setPatterns] = useState([]);
        const [apiKeys, setApiKeys] = useState([]);
        const [status, setStatus] = useState({ tone: 'loading', message: 'Loading pattern rules…' });
        const [toasts, setToasts] = useState([]);
        const [form, setForm] = useState(emptyForm);
        const [submitting, setSubmitting] = useState(false);
        const [editorOpen, setEditorOpen] = useState(false);
        const [editorMode, setEditorMode] = useState('create');
        const [editingRecord, setEditingRecord] = useState(null);

        const pushToast = (tone, message) => {
          const id = Date.now() + Math.random();
          setToasts(prev => [...prev, { id, tone, message }]);
          setTimeout(() => {
            setToasts(prev => prev.filter(toast => toast.id !== id));
          }, 4200);
        };

        const dismissToast = id => {
          setToasts(prev => prev.filter(toast => toast.id !== id));
        };

        const loadAll = async () => {
          try {
            setStatus({ tone: 'loading', message: 'Loading pattern rules…' });
            const [patternResp, keyResp] = await Promise.all([
              fetch('/config/api/patterns', { headers: { Accept: 'application/json' } }),
              fetch('/config/api/keys', { headers: { Accept: 'application/json' } })
            ]);
            if (!patternResp.ok) throw new Error(`Patterns request failed (${patternResp.status})`);
            if (!keyResp.ok) throw new Error(`API keys request failed (${keyResp.status})`);
            const patternData = await patternResp.json();
            const keyData = await keyResp.json();
            const patternItems = Array.isArray(patternData.items) ? patternData.items : [];
            setPatterns(patternItems);
            const keyItems = Array.isArray(keyData.items) ? keyData.items : [];
            setApiKeys(keyItems);
            setStatus({
              tone: 'success',
              message: `Loaded ${patternItems.length} pattern rule${patternItems.length === 1 ? '' : 's'}.`
            });
          } catch (error) {
            const message = `Unable to load configuration: ${error.message}`;
            setStatus({ tone: 'error', message });
            pushToast('error', message);
          }
        };

        useEffect(() => {
          loadAll();
        }, []);

        const stringifyMatchers = matcherList => {
          if (!Array.isArray(matcherList)) return '';
          return matcherList
            .map(item => {
              if (!item || !item.path) return '';
              if (item.equals !== undefined) return `${item.path} => equals:${item.equals}`;
              if (item.contains !== undefined) return `${item.path} => contains:${item.contains}`;
              if ('exists' in item && item.exists) return item.path;
              return item.path;
            })
            .filter(Boolean)
            .join('\n');
        };

        const formatMatchers = matcherList => {
          if (!Array.isArray(matcherList) || !matcherList.length) return '—';
          return matcherList
            .map(matcher => {
              if (!matcher) return '';
              if (matcher.equals !== undefined) return `${matcher.path} equals “${matcher.equals}”`;
              if (matcher.contains !== undefined) return `${matcher.path} contains “${matcher.contains}”`;
              if (matcher.exists) return `${matcher.path} exists`;
              return matcher.path;
            })
            .filter(Boolean)
            .join(', ');
        };

        const parseListInput = text => text.split(/\r?\n/).map(item => item.trim()).filter(Boolean);

        const openCreate = () => {
          const defaultKey = apiKeys.length ? apiKeys[0].name : '';
          setEditorMode('create');
          setEditingRecord(null);
          setForm({ ...emptyForm, apiKeyName: defaultKey });
          setEditorOpen(true);
        };

        const openEdit = pattern => {
          if (!pattern) return;
          setEditorMode('edit');
          setEditingRecord(pattern);
          setForm({
            name: pattern.name || '',
            context: pattern.context || 'request',
            apiKeyName: pattern.apiKeyName || (apiKeys.length ? apiKeys[0].name : ''),
            paths: Array.isArray(pattern.paths) ? pattern.paths.join('\n') : '',
            matchers: stringifyMatchers(pattern.matchers)
          });
          setEditorOpen(true);
        };

        const closeEditor = () => {
          setEditorOpen(false);
          setEditorMode('create');
          setEditingRecord(null);
          setForm({ ...emptyForm });
        };

        const handleFormChange = event => {
          const { name, value } = event.target;
          setForm(prev => ({ ...prev, [name]: value }));
        };

        const handleEditorSubmit = async event => {
          event.preventDefault();
          const name = (form.name || '').trim();
          const apiKeyName = (form.apiKeyName || '').trim();
          const paths = parseListInput(form.paths);
          const matchers = parseListInput(form.matchers)
            .map(line => {
              const [path, match] = line.split(/\s*=>\s*/);
              if (!path) return null;
              if (!match) {
                return { path: path.trim(), exists: true };
              }
              const eqMatch = match.match(/^equals:(.*)$/i);
              const containsMatch = match.match(/^contains:(.*)$/i);
              if (eqMatch) {
                return { path: path.trim(), equals: eqMatch[1].trim() };
              }
              if (containsMatch) {
                return { path: path.trim(), contains: containsMatch[1].trim() };
              }
              return { path: path.trim(), equals: match.trim() };
            })
            .filter(Boolean);

          if (!name || !apiKeyName || !paths.length || !matchers.length) {
            pushToast('info', 'Provide name, API key, at least one path, and at least one matcher.');
            return;
          }

          const payload = {
            name,
            context: form.context,
            apiKeyName,
            paths,
            matchers
          };

          setSubmitting(true);
          try {
            if (editorMode === 'create') {
              const response = await fetch('/config/api/patterns', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', Accept: 'application/json' },
                body: JSON.stringify(payload)
              });
              if (!response.ok) {
                const data = await response.json().catch(() => ({}));
                throw new Error(data.message || data.error || `Request failed (${response.status})`);
              }
              pushToast('success', `Pattern “${name}” created.`);
              closeEditor();
              await loadAll();
            } else if (editingRecord && editingRecord.id) {
              const response = await fetch('/config/api/patterns', {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json', Accept: 'application/json' },
                body: JSON.stringify({ ...payload, id: editingRecord.id })
              });
              if (!response.ok) {
                const data = await response.json().catch(() => ({}));
                throw new Error(data.message || data.error || `Request failed (${response.status})`);
              }
              pushToast('success', `Pattern “${name}” updated.`);
              closeEditor();
              await loadAll();
            } else {
              throw new Error('Missing pattern identifier.');
            }
          } catch (error) {
            pushToast('error', `Save failed: ${error.message}`);
          } finally {
            setSubmitting(false);
          }
        };

        const handleDelete = async record => {
          if (!record || !record.id) return;
          const confirmed = window.confirm(`Delete pattern “${record.name}”?`);
          if (!confirmed) return;
          try {
            const response = await fetch('/config/api/patterns', {
              method: 'DELETE',
              headers: { 'Content-Type': 'application/json', Accept: 'application/json' },
              body: JSON.stringify({ id: record.id })
            });
            if (!response.ok) {
              const data = await response.json().catch(() => ({}));
              throw new Error(data.message || data.error || `Request failed (${response.status})`);
            }
            pushToast('success', `Pattern “${record.name}” removed.`);
            await loadAll();
          } catch (error) {
            pushToast('error', `Delete failed: ${error.message}`);
          }
        };

        return (
          <>
            <TopNavigation current="patterns" />
            <ToastStack toasts={toasts} dismiss={dismissToast} />
            <StatusBanner status={status} />
            <div className="mt-6 space-y-5 rounded-3xl border border-slate-200 bg-white/90 p-6 shadow-sm">
              <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
                <div>
                  <h2 className="text-lg font-semibold text-slate-800">Pattern Rules</h2>
                  <p className="text-sm text-slate-500">Patterns evaluate JSON matchers and reference an API key.</p>
                </div>
                <div className="flex gap-2">
                  <button
                    type="button"
                    onClick={loadAll}
                    className="rounded-lg border border-slate-300 px-3 py-1.5 text-sm font-medium text-slate-600 hover:bg-slate-100"
                  >
                    Refresh
                  </button>
                  <button
                    type="button"
                    onClick={openCreate}
                    className="rounded-lg bg-blue-600 px-3 py-1.5 text-sm font-semibold text-white shadow hover:bg-blue-700 disabled:opacity-60"
                    disabled={apiKeys.length === 0}
                  >
                    New Pattern
                  </button>
                </div>
              </div>

              {patterns.length === 0 ? (
                <div className="rounded-2xl border border-dashed border-slate-300 bg-slate-50 px-4 py-12 text-center text-sm text-slate-500">
                  No patterns configured yet.
                </div>
              ) : (
                <div className="space-y-4">
                  {patterns.map(pattern => (
                    <div key={pattern.id} className="space-y-3 rounded-2xl border border-slate-200 bg-white p-4 shadow-sm">
                      <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
                        <div>
                          <h3 className="text-base font-semibold text-slate-800">{pattern.name}</h3>
                          <p className="text-xs uppercase tracking-wide text-slate-400">{pattern.context} • API key {pattern.apiKeyName}</p>
                        </div>
                        <div className="flex gap-2">
                          <button
                            type="button"
                            onClick={() => openEdit(pattern)}
                            className="rounded-md border border-slate-300 px-3 py-1 text-xs font-medium text-slate-600 hover:bg-slate-100"
                          >
                            Edit
                          </button>
                          <button
                            type="button"
                            onClick={() => handleDelete(pattern)}
                            className="rounded-md border border-rose-200 px-3 py-1 text-xs font-medium text-rose-600 hover:bg-rose-50"
                          >
                            Delete
                          </button>
                        </div>
                      </div>
                      <div className="grid gap-3 text-sm text-slate-600 md:grid-cols-2">
                        <div>
                          <p className="font-semibold text-slate-700">Extraction Paths</p>
                          <ul className="mt-1 space-y-1 font-mono text-xs">
                            {(pattern.paths || []).map((path, index) => (
                              <li key={index}>{path}</li>
                            ))}
                          </ul>
                        </div>
                        <div>
                          <p className="font-semibold text-slate-700">Matchers</p>
                          <p className="mt-1 text-xs text-slate-600">{formatMatchers(pattern.matchers)}</p>
                        </div>
                      </div>
                      <p className="text-xs text-slate-400">Updated {pattern.updated_at ? new Date(pattern.updated_at).toLocaleString() : 'unknown'}.</p>
                    </div>
                  ))}
                </div>
              )}

              {apiKeys.length === 0 ? (
                <p className="text-xs text-amber-600">Configure at least one API key before adding patterns.</p>
              ) : null}
            </div>

            <Modal
              open={editorOpen}
              title={editorMode === 'create' ? 'New Pattern Rule' : `Edit ${editingRecord ? editingRecord.name : 'Pattern'}`}
              description="Patterns evaluate matchers and choose which API key Guardrails uses."
              onClose={() => {
                if (!submitting) {
                  closeEditor();
                }
              }}
            >
              <form onSubmit={handleEditorSubmit} className="space-y-4">
                <div className="space-y-2">
                  <label className="block text-sm font-medium text-slate-700" htmlFor="pattern-name">
                    Rule Name
                  </label>
                  <input
                    id="pattern-name"
                    name="name"
                    type="text"
                    className="w-full rounded-lg border border-slate-300 px-3 py-2 text-sm focus:border-primary focus:ring-primary"
                    value={form.name}
                    onChange={handleFormChange}
                    placeholder="LLM request selectors"
                    disabled={submitting}
                  />
                </div>
                <div className="space-y-2">
                  <label className="block text-sm font-medium text-slate-700" htmlFor="pattern-context">
                    Context
                  </label>
                  <select
                    id="pattern-context"
                    name="context"
                    className="w-full rounded-lg border border-slate-300 px-3 py-2 text-sm focus:border-primary focus:ring-primary"
                    value={form.context}
                    onChange={handleFormChange}
                    disabled={submitting}
                  >
                    <option value="request">Request</option>
                    <option value="response">Response</option>
                  </select>
                </div>
                <div className="space-y-2">
                  <label className="block text-sm font-medium text-slate-700" htmlFor="pattern-api-key">
                    API Key
                  </label>
                  <select
                    id="pattern-api-key"
                    name="apiKeyName"
                    className="w-full rounded-lg border border-slate-300 px-3 py-2 text-sm focus:border-primary focus:ring-primary"
                    value={form.apiKeyName}
                    onChange={handleFormChange}
                    disabled={submitting || apiKeys.length === 0}
                  >
                    {apiKeys.length === 0 ? <option value="">No API keys configured</option> : null}
                    {apiKeys.map(key => (
                      <option key={key.id} value={key.name}>{key.name}</option>
                    ))}
                  </select>
                  <p className="text-xs text-slate-500">Populate API keys on the dedicated page first.</p>
                </div>
                <div className="space-y-2">
                  <label className="block text-sm font-medium text-slate-700" htmlFor="pattern-paths">
                    Extraction Paths
                  </label>
                  <textarea
                    id="pattern-paths"
                    name="paths"
                    rows="3"
                    className="w-full rounded-lg border border-slate-300 px-3 py-2 text-sm focus:border-primary focus:ring-primary"
                    value={form.paths}
                    onChange={handleFormChange}
                    placeholder=".messages[-1].content"
                    disabled={submitting}
                  ></textarea>
                  <p className="text-xs text-slate-500">Enter one JSON selector per line.</p>
                </div>
                <div className="space-y-2">
                  <label className="block text-sm font-medium text-slate-700" htmlFor="pattern-matchers">
                    Matchers
                  </label>
                  <textarea
                    id="pattern-matchers"
                    name="matchers"
                    rows="4"
                    className="w-full rounded-lg border border-slate-300 px-3 py-2 text-sm focus:border-primary focus:ring-primary"
                    value={form.matchers}
                    onChange={handleFormChange}
                    placeholder={`.model => equals:llama3.1\n.messages[-1].role => equals:user`}
                    disabled={submitting}
                  ></textarea>
                  <p className="text-xs text-slate-500">
                    Use “path => equals:value”, “path => contains:value”, or “path” (for existence checks).
                  </p>
                </div>
                <div className="flex justify-end gap-3 pt-2">
                  <button
                    type="button"
                    className="rounded-md border border-slate-300 px-4 py-2 text-sm font-medium text-slate-600 hover:bg-slate-100 disabled:opacity-60"
                    onClick={() => {
                      if (!submitting) {
                        closeEditor();
                      }
                    }}
                    disabled={submitting}
                  >
                    Cancel
                  </button>
                  <button
                    type="submit"
                    className="rounded-md bg-blue-600 px-4 py-2 text-sm font-semibold text-white shadow hover:bg-blue-700 disabled:opacity-60"
                    disabled={submitting || apiKeys.length === 0}
                  >
                    {submitting ? 'Saving…' : editorMode === 'create' ? 'Save Pattern' : 'Save Changes'}
                  </button>
                </div>
              </form>
            </Modal>
          </>
        );
      };

      function CollectorApp() {
        const [status, setStatus] = useState({ tone: 'muted', message: '' });
        const [loading, setLoading] = useState(true);
        const [collector, setCollector] = useState({ total: 0, remaining: 0, entries: [] });
        const [collectInput, setCollectInput] = useState('3');
        const [expandedEntries, setExpandedEntries] = useState([]);

        const totalCaptured = collector.entries ? collector.entries.length : 0;
        const quotaRemaining = collector.remaining || 0;

        const notify = (tone, message) => setStatus({ tone, message });

        const loadCollector = async () => {
          const resp = await fetch('/collector/api', { method: 'GET' });
          if (!resp.ok) throw new Error('Failed to load collector state');
          const data = await resp.json();
          setCollector({
            total: data.total || 0,
            remaining: data.remaining || 0,
            entries: Array.isArray(data.entries) ? data.entries : []
          });
          setCollectInput(prev =>
            prev === '' ? String(data.remaining || data.total || 0) : prev
          );
        };

        useEffect(() => {
          (async () => {
            try {
              await loadCollector();
              notify('info', 'Collector state synced.');
            } catch (err) {
              notify('error', err.message || 'Failed to load collector state.');
            } finally {
              setLoading(false);
            }
          })();
        }, []);

        const [handleCollect, collecting] = useAsyncCallback(async () => {
          const parsed = parseInt(collectInput, 10);
          if (!Number.isFinite(parsed) || parsed < 0) {
            notify('error', 'Enter a non-negative count.');
            return;
          }
          const capped = Math.min(parsed, MAX_SELECTORS * 4);
          const resp = await fetch('/collector/api', {
            method: 'POST',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify({ count: capped })
          });
          if (!resp.ok) {
            notify('error', 'Collector request failed.');
            return;
          }
          const data = await resp.json();
          setCollector({
            total: data.total || 0,
            remaining: data.remaining || 0,
            entries: Array.isArray(data.entries) ? data.entries : []
          });
          setCollectInput(String(data.remaining || data.total || 0));
          setExpandedEntries([]);
          notify('success', `Collection armed for ${data.total || 0} pairs.`);
        });

        const [handleRefresh, refreshing] = useAsyncCallback(async () => {
          try {
            await loadCollector();
            notify('info', 'Collector entries refreshed.');
          } catch (err) {
            notify('error', err.message || 'Refresh failed.');
          }
        });

        const isExpanded = id => expandedEntries.includes(id);

        const toggleEntry = id => {
          setExpandedEntries(prev =>
            prev.includes(id) ? prev.filter(item => item !== id) : [...prev, id]
          );
        };

        if (loading) {
          return (
            <div className="flex h-64 items-center justify-center rounded-3xl border border-slate-200 bg-white shadow-sm">
              <span className="text-sm text-slate-500">Loading collector interface…</span>
            </div>
          );
        }

        return (
          <div className="space-y-8">
            {status.message ? (
              <div className={classNames('rounded-2xl border px-4 py-3 text-sm shadow-sm', STATUS_TONES[status.tone] || STATUS_TONES.muted)}>
                {status.message}
              </div>
            ) : null}

            <section className="grid gap-6 md:grid-cols-3">
              <SummaryPill label="Captured" value={`${totalCaptured}`} />
              <SummaryPill label="Remaining Quota" value={`${quotaRemaining}`} />
              <SummaryPill label="Configured Collectors" value={`${collector.total || 0}`} />
            </section>

            <section className="rounded-3xl border border-slate-200 bg-white/90 p-6 shadow-sm">
              <div className="flex flex-col gap-4 md:flex-row md:items-end md:justify-between">
                <div className="space-y-2">
                  <label className="text-sm font-medium text-slate-700">Pairs to capture</label>
                  <input
                    type="number"
                    min="0"
                    value={collectInput}
                    onChange={event => setCollectInput(event.target.value)}
                    className="w-32 rounded-lg border border-slate-300 bg-white px-3 py-2 text-sm focus:border-primary focus:ring-primary"
                  />
                  <p className="text-xs text-slate-500">Collector resets existing samples when armed.</p>
                </div>
                <div className="flex flex-col gap-3 sm:flex-row">
                  <button
                    type="button"
                    onClick={handleCollect}
                    disabled={collecting}
                    className={classNames(
                      'inline-flex items-center justify-center rounded-lg px-5 py-2 text-sm font-semibold text-white shadow',
                      'bg-blue-600 bg-primary',
                      collecting ? 'opacity-70' : 'hover:bg-blue-700 hover:bg-primary-dark'
                    )}
                  >
                    {collecting ? 'Arming…' : 'Collect Pairs'}
                  </button>
                  <button
                    type="button"
                    onClick={handleRefresh}
                    disabled={refreshing}
                    className={classNames(
                      'inline-flex items-center justify-center rounded-lg border border-slate-300 px-5 py-2 text-sm font-semibold text-slate-600',
                      refreshing ? 'opacity-70' : 'hover:bg-slate-100'
                    )}
                  >
                    {refreshing ? 'Refreshing…' : 'Refresh Entries'}
                  </button>
                </div>
              </div>
            </section>

            <section className="rounded-3xl border border-slate-200 bg-white/90 p-6 shadow-sm">
              <header className="mb-4 flex items-center justify-between">
                <div>
                  <h2 className="text-lg font-semibold text-slate-800">Collected Entries</h2>
                  <p className="text-sm text-slate-500">
                    Expand an entry to inspect captured request and response payloads.
                  </p>
                </div>
                <span className="rounded-full bg-slate-200 px-3 py-1 text-xs font-semibold text-slate-700">
                  {totalCaptured} captured
                </span>
              </header>

              {totalCaptured === 0 ? (
                <div className="rounded-2xl border border-dashed border-slate-300 bg-slate-50 px-4 py-12 text-center text-sm text-slate-500">
                  No payloads captured yet. Arm the collector above and exercise the proxy.
                </div>
              ) : (
                <div className="space-y-4">
                  {collector.entries.map((entry, index) => {
                    const entryId = entry.id || `entry-${index}`;
                    const expanded = isExpanded(entryId);
                    return (
                      <article key={entryId} className="rounded-2xl border border-slate-200 bg-white/95 shadow-sm">
                        <button
                          type="button"
                          onClick={() => toggleEntry(entryId)}
                          className="flex w-full items-center justify-between px-5 py-4 text-left text-sm font-medium text-slate-700 hover:bg-slate-50"
                        >
                          <span>
                            Pair {index + 1} •{' '}
                            <span className="font-normal text-slate-500">
                              {entry.collected_at ? new Date(entry.collected_at).toLocaleString() : 'timestamp unknown'}
                            </span>
                          </span>
                          <span className="text-xl text-slate-400">{expanded ? '−' : '+'}</span>
                        </button>
                        {expanded ? (
                          <div className="grid gap-6 border-t border-slate-100 px-5 py-6 md:grid-cols-2">
                            <PayloadTree
                              title="Request Payload"
                              bodyText={(entry.request && entry.request.body) || ''}
                            />
                            <PayloadTree
                              title="Response Payload"
                              bodyText={(entry.response && entry.response.body) || ''}
                            />
                          </div>
                        ) : null}
                      </article>
                    );
                  })}
                </div>
              )}
            </section>
          </div>
        );
      }

      const ConfigPage = () => {
        const [activeView, setActiveView] = useState('config');
        useEffect(() => {
          document.title = activeView === 'collector'
            ? 'Guardrails Payload Collector'
            : 'Guardrails Scan Configuration';
        }, [activeView]);

        return (
          <div className="space-y-10">
            <div className="flex justify-center">
              <div className="inline-flex rounded-full border border-slate-200 bg-white/80 p-1 shadow-sm">
                {VIEW_OPTIONS.map(option => {
                  const isActive = activeView === option.id;
                  return (
                    <button
                      key={option.id}
                      type="button"
                      onClick={() => setActiveView(option.id)}
                      className={classNames(
                        'mx-1 rounded-full px-4 py-2 text-sm font-semibold transition',
                        isActive
                          ? 'bg-blue-600 bg-primary text-white shadow hover:bg-blue-700 hover:bg-primary-dark'
                          : 'text-slate-600 hover:bg-slate-100'
                      )}
                    >
                      {option.label}
                    </button>
                  );
                })}
              </div>
            </div>
            {activeView === 'collector' ? <CollectorApp /> : <ConfigApp />}
          </div>
        );
      };

      if (PAGE_KIND === 'keys') {
        document.title = 'Guardrails API Keys';
      } else if (PAGE_KIND === 'patterns') {
        document.title = 'Guardrails Pattern Rules';
      }

      const AppComponent = PAGE_KIND === 'keys'
        ? ApiKeysApp
        : PAGE_KIND === 'patterns'
          ? PatternsApp
          : ConfigPage;

      ReactDOM.createRoot(document.getElementById('root')).render(<AppComponent />);
    </script>
  </body>
</html>
